import { NextRequest, NextResponse } from 'next/server';
import mongoose from 'mongoose';
import { TwoFactorMethod, ActivityType } from '../../../../../types/security';
import connectToDatabase from '../../../../../lib/db/connect';
import { getUserModel } from '../../../../../lib/db/models/user';
import { logServerActivity } from '../../../../../lib/utils';
import { generateVerificationCode } from '../../../../../lib/utils/verification';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { userId, method } = body;

    if (!userId) {
      return NextResponse.json(
        { error: 'User ID is required' },
        { status: 400 }
      );
    }

    if (!method || !['app', 'email'].includes(method)) {
      return NextResponse.json(
        { error: 'Valid authentication method is required. Must be app or email.' },
        { status: 400 }
      );
    }

    // Connect to the database and get the user
    await connectToDatabase();
    const UserModel = getUserModel();

    // Use findById with proper ObjectId validation
    const isValidObjectId = mongoose.Types.ObjectId.isValid(userId);
    const user = isValidObjectId
      ? await UserModel.findById(userId)
      : await UserModel.findOne({ email: userId });

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    // Initialize twoFactorAuth if it doesn't exist
    if (!user.twoFactorAuth) {
      user.twoFactorAuth = {
        enabled: true,
        method: method as TwoFactorMethod,
        verified: false,
        lastUpdated: new Date().toISOString()
      };
    }

    // Generate a new verification code
    const verificationCode = generateVerificationCode();

    // In a real app, we would send the verification code via email
    // For app method (TOTP), no code needs to be sent - generated by the authenticator app

    // For development purposes, we'll store the code in user.twoFactorAuth.temporaryCode
    // In a real app, this would be encrypted and time-limited
    user.twoFactorAuth.method = method as TwoFactorMethod;
    user.twoFactorAuth.temporaryCode = verificationCode;
    user.twoFactorAuth.codeGeneratedAt = new Date().toISOString();
    await user.save();

    // Log the activity
    logServerActivity(userId, ActivityType.TWO_FACTOR_SETUP, {
      method: method as TwoFactorMethod,
      action: 'code_resent'
    });

    // IMPORTANT SECURITY NOTE:
    // In a production environment, you would:
    // 1. Never return the actual verification code in the response
    // 2. Send the code via email using a service like SendGrid or Gmail SMTP
    // 3. Store a salted and hashed version of the code, not plaintext

    // For development only - return the code for testing (REMOVE IN PRODUCTION!)
    const developmentResponse = process.env.NODE_ENV === 'development' ?
      { verificationCode } : {};

    return NextResponse.json({
      success: true,
      message: `Verification code sent via ${method}`,
      sentTo: method === 'email' ? user.email : 'authenticator app',
      ...developmentResponse
    });

  } catch (error) {
    console.error('Failed to resend 2FA code:', error);
    return NextResponse.json(
      { error: 'Failed to send verification code' },
      { status: 500 }
    );
  }
}
